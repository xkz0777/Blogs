---
date: 2021-07-20 20:12:55
title: 程序设计II第四次上机
tags: ['C/C++','动态规划']
author: xkz
categories: 'C/C++'
img: /medias/featureimages/sj4.jpg
summary: 程序设计II上机题解，本次共有4题
---

## 通过oj题目的最大概率

### 题目描述

小明尝试了很多办法还是没法通过本周的上机题，他决定**铤而走险**。
他的室友是一名大佬，写出来的代码优雅且整洁，小明知道，如果他能**抄到更多个字的室友的代码，就有更大的概率通过上机题。**

由于室友的代码具有局部不可破坏性，不太聪明的小明只能挑取一些行**整行抄取**。但是提交的代码如果有**连着两行完全一样**，就会在代码查重环节被助教**当场抓获并记零分**。

请你帮帮小明：在不被当场抓获的前提下，挑选哪些行复制粘贴，才能抄到最多字呢？

番外:可惜的是小明最终仍然没有通过代码查重，同学们不要学习他。

### 输入描述

输入是以空格分割的一系列整数，每个数字代表该行代码有多少字
由于题目不难，代码不会超过100行，但也不会少于一行。另外，由于他的室友严格遵守代码规范要求，每行的字数n满足0<=n<=80。

### 输出描述

输出为一个整数，代表在不会被助教**当场抓获**的情况下，小明最多能抄到多少字

### 样例输入

```
10 24 13 5
```

### 样例输出

```
29
```

### 样例解释

小明抄第二行(24)和第四行(5)代码能抄到最多的字数,一共抄了29个字

### 样例输入

```
4 14 18 6 2
```

### 样例输出

```
24
```

### 样例解释

抄1、3、5行能抄到最多

### 解题思路

~~可以说这个小明就是我了，天天就知道抄作业（bushi）~~

本题明显是个 dp（Dynamic Programming，动态规划） 题，重要的是**确定状态转移方程**，本题显然是个一维的dp，我们建立两个数组 `f` 和 `l`，其中 `l[i]` 表示第 i 行代码的字数（存储输入），`f[i]` 表示当小明抄到第 i 行（含）时可以抄到的最大行数，由于两行不能连续抄，因此小明抄到第 i 行时，要么选择抄第 i 行，得到的行数为 `f[i-2]+l[i]`，要么选择不抄第 i 行，得到的行数为 `f[i-1]`

由此我们得到状态转移方程：

```cpp
f[i] = max(f[i-1], f[i-2] + l[i]);
```

同时还应**确定初始条件**，显然应该为 `f[0] = 0, f[1] = l[1]`

### AC代码

```cpp
#include <iostream>
using namespace std;

int l[102];  //存储每行代码的字数，这里令l[0]=0,从l[1]开始存储
int f[102];  //f[n]表示到第n行为止可以抄到的最大代码行数
//状态转移方程：f[n]=max{f[n-2]+l[n],f[n-1]}
int main() {
    int i = 1;
    cin >> l[i];
    i++;
    f[1] = l[1];                                //初始化
    while (cin >> l[i]) {                       //读入
        f[i] = max(f[i - 2] + l[i], f[i - 1]);  //状态转移
        i++;
    }
    cout << f[i - 1];  //输出
}
```



## 吃金币

### 题目描述

**你是小明的室友。**

一个N x N的网格(grid) 代表了一块空地，每个格子由以下三种数字的一种来表示：

0 表示这个格子是空的，所以你可以穿过它。
1 表示这个格子里放了一枚金币，你可以捡起金币然后穿过它。
-1 表示这个格子里有巨石，挡着你的路。
你的任务是在遵守下列规则的情况下，捡到尽可能多的金币：

**从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走**，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
**当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走**，并且只能穿越有效的格子；
当你经过一个格子且这个格子包含一个金币时，你将捡起金币并且这个格子会变成空的（值变为0）；
**如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则认为你无法获得任何金币。**

### 输入描述

输入是一个n×n的矩阵，n的范围是[1, 50]。不同数字之间用空格分割，格式如下

0 1 -1
1 0 -1
1 1 1

起点（左上角）和终点（右下角）不会是石头。

### 输出描述

输出为一个整数，是能捡到的最多的金币数。

### 样例输入

```
0 1 -1
1 0 -1
1 1 1
```

### 样例输出

```
5
```

### 样例解释

你从起点开始，依次向下、向下、向右、向右，到达右下角，此时有4个金币，再向左、向上、向上、向左，回到起点。这样一共能获得5个金币。

### 解题思路

乍一看这题像是一个二维 dp 题，但是如果用二维 dp ，**不满足无后效性**，因为一遍从 `(0, 0)` 走到 `(n - 1, n - 1)` 后回来时的路径会受之前走的路径的影响。因此本题的巧妙之处在于，把一个人从 `(0, 0)` 到 `(n - 1,n - 1)` 走个来回，**等效于两个人同时从 `(0, 0)` 走到 `(n - 1, n - 1)`**这时就满足无后效性，此时是一个**三维 dp** （有四个变量，为两个人的坐标，但坐标之间有联系：$x_1+y_1=x_2+y_2$），我们开一个三维数组`coin` , `coin[i][j][k]` 表示两个人的坐标分别为 `(i, k - i) , (j, k - j)` 时总共吃到的金币数量 。

**状态转移方程**为：

```cpp
if(i != j){
    coin[i][j][k] = max(coin[i-1][j][k-1], coin[i][j-1][k-1],
    coin[i-1][j-1][k-1], coin[i][j][k-1]) + grid[i][k-i]+grid[j][k-j]
}
else if(i == j){
    coin[i][j][k] = max(coin[i-1][j][k-1], coin[i][j-1][k-1],
    coin[i-1][j-1][k-1], coin[i][j][k-1]) + grid[i][k-i]
```

由来：一共有四种状态可以扩展到 `(i,j,k)` 状态：两个人分别可以向下或者向右走，一共2*2=4种可能，但是如果两个人恰好走到了同一处，金币就只能吃到一格，因此分两种情况来转移，每一步都取最大（最优子结构）。

本题的第二个难点在于**对石头的处理**，我的处理方式为：刚开始**把 `coin` 数组全部置为 -1**，仅把 `coin[1][1][2]` 的值设为 `grid[1][1]` ，之后在状态转移的过程中，如果有某个点是石头，则跳过，如果某个点的**父节点（这里我将能够直接扩展出该点的四个点称为父节点）全部都是 -1** ，也跳过（因为既然其父节点无法被扩展到，该点自然也无法被走到）。之后再进行状态转移即可。

此外这里还需要注意**会有走不通的可能**，最简单的办法是进行一遍搜索，看能否走通，由于这是最简单的 dfs，这里不过多赘述。

### AC代码

**注意：**原题的AC代码其实与这个代码稍有不同，因为其输入数据没有给 n，且每行的末尾还有空格，所以需要一些特殊的输入技巧，但由于输入并不是这题的重点，我就放了简单版的输入在博客上，如果读者希望拿这个代码到 CODIA 上提交，记得修改 `read()` 函数

```cpp
#include <cmath>
#include <cstring>
#include <iostream>
using namespace std;
int n;
int grid[251][251];      //意义同题述
int coin[251][251][501];

int max(int a, int b, int c, int d) {
    a = max(a, b);
    a = max(a, c);
    a = max(a, d);
    return a;
}

void read() {  //数据读入
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            grid[i][j] = tmp[(i - 1) * n + j];
        }
    }
}

void initialize() {  //每个点初始值都设为-1
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            for (int k = 1; k <= 2 * n; ++k) {
                coin[i][j][k] = -1;
            }
        }
    }
    coin[1][1][2] = grid[1][1];
}

void dp() {
    for (int k = 1; k <= 2 * n; ++k) {
        for (int x1 = 1; x1 <= n; ++x1) {      //x1
            for (int x2 = 1; x2 <= n; ++x2) {  //x2
                int y2 = k - x2;
                int y1 = k - x1;
                if (grid[x1][y1] == -1 || grid[x2][y2] == -1) {
                    continue;
                }
                int s = max(coin[x1 - 1][x2][k - 1],
                            coin[x1][x2 - 1][k - 1],
                            coin[x1 - 1][x2 - 1][k - 1],
                            coin[x1][x2][k - 1]);
                if (s == -1) {
                    continue;
                }
                else {
                    coin[x1][x2][k] = s + grid[x1][y1] + grid[x2][y2];
                    if (x1 == x2) {
                        coin[x1][x2][k] -= grid[x1][y1];
                    }
                }
            }
        }
    }
}

bool visited[251][251];
int dx[2] = {0, 1};
int dy[2] = {1, 0};
void dfs(int x, int y) {
    visited[x][y] = true;
    for (int i = 0; i < 2; ++i) {
        int xx = x + dx[i];
        int yy = y + dy[i];
        if ((grid[xx][yy] != -1) && xx <= n && yy <= n && !visited[xx][yy]) {
            dfs(xx, yy);
        }
    }
}

int main() {
    read();
    initialize();
    dfs(1, 1);
    if (!visited[n][n]) {
        cout << "0";
        return 0;
    }
    dp();
    cout << coin[n][n][2 * n];
}
```



## 全排列输出

### 题目描述

给定一**没有重复**数字的序列，返回其所有可能的全排列。输出需要按照输入的从前到后的顺序排列。具体参考样例数据。

### 输入描述

输入是用空格分割的几个数字，数字个数n满足1 <= n <= 9.

### 输出描述

输出你的排列，每行一个，按照从小到大顺序。

### 样例输入

```
2 1 3
```

### 样例输出

```
213
231
123
132
321
312
```

### 解题思路

#### 方法一：奇技淫巧

由于 `STL` 中存在神奇的库函数 `next_permutation` 它接收一个排列数组的起止迭代器作为参数（STL惯用的左闭右开），用法类似`sort` 也可以自定 `cmp` 函数进行生成，会把给定的数组内容转换为下一个排列。

这里我没有选择用写 `cmp` 函数的方式来做这题，我先生成了按照 1 - n 的顺序的所有排列，再按照题给的顺序映射回来，例如，按 1 - 3 的自然顺序生成的第一个排列为 `123` ，按照题目的映射规则有：`1 -> 2, 2-> 1,3 -> 3`，于是我们得到排列 `213` ，AC代码如下：

```cpp
#include <algorithm>
#include <iostream>
using namespace std;

int map[10];  //用于映射
int fact[10];
int main() {
    int i = 0;
    int n;
    while (cin >> n) {
        ++i;
        map[i] = n;
    }
    int ans[i];
    for (int j = 0; j < i; ++j) {
        ans[j] = j + 1;
    }
    fact[0] = 1;
    for (int k = 1; k <= 9; ++k) {
        fact[k] = k * fact[k - 1];
    }
    for (int k = 1; k <= fact[i]; ++k) {
        for (int j = 0; j < i; ++j) {
            cout << map[ans[j]];
        }
        cout << endl;
        next_permutation(ans, ans + i);
    }
}
```

用这个方法提交以后，我总觉得内心不安，~~怕助教找到我，叫我重写~~，因此我灵机一动~~上网一搜~~，写出了 `next_permutation` 函数的实现，代码如下

```cpp
void nextPermutation(int *s,int *e) {  //s和e是起止迭代器，左开右闭，保持与STL一致
    int j;
    int l = e - s;
    for (j = l - 2; j >= 0; --j) {
        if (s[j] < s[j + 1]) {
            break;
        }
    }
    int k, minnum;
    minnum = INFINITY;
    for (int i = j + 1; i < l; ++i) {
        if (s[i] > s[j] && s[i] < minnum) {
            minnum = s[i];
            k = i;
        }
    }
    swap(s, j, k);
    reverse(s, j + 1, l);
}
```

思路：要得到下一个全排列，一定是保持目前排列左边的某几位不动，改变较右边几位的顺序，而右边要能够改变**必须是一个部分升序的序列**，改变的方式是：找到最靠右的一位应该改变的数（这里我也不太会描述，之后用例子来说），使他变大（不能是简单的加一，因为这样可能不能满足排列的互异特征），之后其右边的所有位应该按升序排列，才是最小的排列。如下例：

146532 -> 152346

从右往左看，由于 6532 已经是完全递减的序列，不满足我们部分升序序列的特征，因此那个应该固定 1 不动，改变 46532，而4要变大，只能跟它右边比它大的数交换，并且那个数应该越小越好，因此它应该跟 5 交换，得到 56432，容易得知，6432 此时一定是逆序的，只要将其再倒转过来，便得到我们要的序列 152346

由上面我们知道，那个“应该改变的数”是一个满足后面条件的 `j` ，`j = max{ i | s[i] < s[i+1]}`，即数组中最靠右的一个比其右边数小的那个数的下标（究极拗口，不如看表达式直观），此时必定有`s[j] < s[j + 1]` ，且 `s[j + 1] - s[n]`段是递减的，并且该片段中一定有比 `s[j]`大的数，由于我们只要求最小的排列，就需要找到 `k` ， `k` 为 `j + 1` 到 `n` 中比`s[j]`大的数里面最小的数的下标，之后交换 `s[j]` 和 `s[k]` ，这样会使得数组的 `j + 1` 到 `n`是逆序的，再把数组的 `j + 1` 到 `n` 部分倒序即可。

代码中用到的`swap()`和`reverse()`函数如下

```cpp
void swap(int a[], int i, int j) {  //交换数组a中的i，j两个元素
    int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
}

void reverse(int a[], int s, int e) {
    //使a数组中[s,e)部分倒序
    int *tmp = new int[l];
    memcpy(tmp, a, sizeof(int) * l);
    for (int i = s, j = 1; i < e; ++i, ++j) {
        tmp[i] = a[e - j];
    }
    memcpy(a, tmp, sizeof(int) * l);
}
```

#### 方法二：搜索（类似八皇后）

思路：每次排出一个排列并输出，一共排 n! 次，即可得到我们的答案。

因此这里我们定义一个函数 `void search(int i, int k);` 其中 `search(i, k)` 表示正在排第 k 次，而由于每次排数都要排 n 位，因此 i 表示排到第 i 位（第 i 位还未排），函数如下，具体写法之后解释

```cpp
void search(int i, int k) {  //排第i位，是第k个
    int r = (k - 1) / fact[n - i] + 1;
    int cnt = 0;
    for (int j = 1; j < 10; ++j) {
        if (!used[j]) {
            cnt++;
        }
        if (cnt == r) {
            cout << num[j];
            used[j] = true;
            break;
        }
    }
    k -= (r - 1) * fact[n - i];
    if (i == n) {
        cout << endl;
        return;
    }
    search(i + 1, k);
}
```

其实该写法是一位一位定出当前所需要的数：第 k 个排列具有的特征是：每一位都是输入里num数组的第 r 个数，其中 r = (k - 1) / fact[n - i] + 1，证明比较容易，读者容易验证，我们这里举个例子来帮助理解：

`123` 的全排列依次为：`123，132，213，231，312，321`，那么第 5 个排列应该是 `312`，第一位是 3，那么其之前的排列应该有 (3 - 1) * fact[2] = 4 个，由此我们不难得到：如果第 i 位是 r，那么一定有：(r - 1) * fact[n - i] <= k < r * fact[n - i] ，因此我们可以挨个确定每一位，此方法当然也可以不用搜索来写，直接递推即可。

## 全排列计数

### 题目描述

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
“123”
“132”
“213”
“231”
“312”
“321”
给定 n 和 k，返回第 k 个排列。

### 输入描述

输入共一行，形如
`n k`
其中两个均为整数，1 <= n <= 9, 1 <= k <= n!

### 输出描述

输出共一行，为对应次序的排列

### 样例输入

```
3 3
```

### 样例输出

```
213
```

### 样例输入

```
4 9
```

### 样例输出

```
2314
```

### 解题思路

很显然，这题我们只要沿用“全排列输出”一题中的方法二即可得到答案，比较简单，直接贴代码：

```cpp
#include <iostream>
using namespace std;
int fact[10];  //打表存储阶乘

void initialize() {
    fact[0] = 1;
    for (int i = 1; i <= 9; ++i) {
        fact[i] = fact[i - 1] * i;
    }
}

int main() {
    int n, k, r;
    cin >> n >> k;
    initialize();
    int queue[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    for (int i = 1; i <= n - 1; ++i) {
        //答案一共有n位，每次循环输出一位
        //思路：开一个队列，初始时存放1-n中的整数，为了方便，以数组的形式表示队列
        //首先确定第一位数：如果第一位数是i，那么以i开头的所有排列应该位于
        //第(i-1)*(n-1)!到i*(n-1)!之间，因此(i-1)*(n-1)!<k<=i*(n-1)!
        //由此可以确定第一位数应该是队列的第r个数
        //其中r=(k-1)/fact[n-i]+1，之后该数移出队列(把它标成0即可)，之后第i位以此类推
        r = (k - 1) / fact[n - i] + 1;
        int cnt = 0;
        for (int j = 1; j < 10; ++j) {
            if (queue[j] != 0) {
                cnt++;
            }
            if (cnt == r) {
                cout << queue[j];
                queue[j] = 0;
                break;
            }
        }
        k -= (r - 1) * fact[n - i];
    }
    for (int j = 1; j <= n; ++j) {
        if (queue[j] != 0) {
            cout << queue[j];
        }
    }
}
```

